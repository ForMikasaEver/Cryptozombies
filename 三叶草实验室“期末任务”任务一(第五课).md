# ä¸‰å¶è‰å®žéªŒå®¤â€œæœŸæœ«ä»»åŠ¡â€æ€»ç»“ï¼ˆç»­ï¼‰(ç¬¬äº”è¯¾)
## ä»»åŠ¡ä¸€ï¼šå®ŒæˆåŠ å¯†åƒµå°¸çš„æ¸¸æˆ
### 5.ERC721æ ‡å‡†å’ŒåŠ å¯†æ”¶è—å“
#### â‘ ä»¥å¤ªåŠä¸Šçš„ä»£å¸
è®©æˆ‘ä»¬æ¥èŠèŠ _ä»£å¸_.

å¦‚æžœä½ å¯¹ä»¥å¤ªåŠçš„ä¸–ç•Œæœ‰ä¸€äº›äº†è§£ï¼Œä½ å¾ˆå¯èƒ½å¬è¿‡äººä»¬èŠåˆ°ä»£å¸â€”â€”å°¤å…¶æ˜¯ ERC20 ä»£å¸.

ä¸€ä¸ª _ä»£å¸_ åœ¨ä»¥å¤ªåŠåŸºæœ¬ä¸Šå°±æ˜¯ä¸€ä¸ªéµå¾ªä¸€äº›å…±åŒè§„åˆ™çš„æ™ºèƒ½åˆçº¦â€”â€”å³å®ƒå®žçŽ°äº†æ‰€æœ‰å…¶ä»–ä»£å¸åˆçº¦å…±äº«çš„ä¸€ç»„æ ‡å‡†å‡½æ•°ï¼Œä¾‹å¦‚ `transfer(address _to, uint256 _value)` å’Œ `balanceOf(address _owner)`.

åœ¨æ™ºèƒ½åˆçº¦å†…éƒ¨ï¼Œé€šå¸¸æœ‰ä¸€ä¸ªæ˜ å°„ï¼Œ`mapping(address => uint256) balances`ï¼Œç”¨äºŽè¿½è¸ªæ¯ä¸ªåœ°å€è¿˜æœ‰å¤šå°‘ä½™é¢ã€‚

æ‰€ä»¥åŸºæœ¬ä¸Šä¸€ä¸ªä»£å¸åªæ˜¯ä¸€ä¸ªè¿½è¸ªè°æ‹¥æœ‰å¤šå°‘è¯¥ä»£å¸çš„åˆçº¦ï¼Œå’Œä¸€äº›å¯ä»¥è®©é‚£äº›ç”¨æˆ·å°†ä»–ä»¬çš„ä»£å¸è½¬ç§»åˆ°å…¶ä»–åœ°å€çš„å‡½æ•°ã€‚

**å®ƒä¸ºä»€ä¹ˆé‡è¦å‘¢ï¼Ÿ**
ç”±äºŽæ‰€æœ‰ ERC20 ä»£å¸å…±äº«å…·æœ‰ç›¸åŒåç§°çš„åŒä¸€ç»„å‡½æ•°ï¼Œå®ƒä»¬éƒ½å¯ä»¥ä»¥ç›¸åŒçš„æ–¹å¼è¿›è¡Œäº¤äº’ã€‚

è¿™æ„å‘³ç€å¦‚æžœä½ æž„å»ºçš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿä¸Žä¸€ä¸ª ERC20 ä»£å¸è¿›è¡Œäº¤äº’ï¼Œé‚£ä¹ˆå®ƒå°±ä¹Ÿèƒ½å¤Ÿä¸Žä»»ä½• ERC20 ä»£å¸è¿›è¡Œäº¤äº’ã€‚ è¿™æ ·ä¸€æ¥ï¼Œå°†æ¥ä½ å°±å¯ä»¥è½»æ¾åœ°å°†æ›´å¤šçš„ä»£å¸æ·»åŠ åˆ°ä½ çš„åº”ç”¨ä¸­ï¼Œè€Œæ— éœ€è¿›è¡Œè‡ªå®šä¹‰ç¼–ç ã€‚ ä½ å¯ä»¥ç®€å•åœ°æ’å…¥æ–°çš„ä»£å¸åˆçº¦åœ°å€ï¼Œç„¶åŽå“—å•¦ï¼Œä½ çš„åº”ç”¨ç¨‹åºæœ‰å¦ä¸€ä¸ªå®ƒå¯ä»¥ä½¿ç”¨çš„ä»£å¸äº†ã€‚

å…¶ä¸­ä¸€ä¸ªä¾‹å­å°±æ˜¯äº¤æ˜“æ‰€ã€‚ å½“äº¤æ˜“æ‰€æ·»åŠ ä¸€ä¸ªæ–°çš„ ERC20 ä»£å¸æ—¶ï¼Œå®žé™…ä¸Šå®ƒåªéœ€è¦æ·»åŠ ä¸Žä¹‹å¯¹è¯çš„å¦ä¸€ä¸ªæ™ºèƒ½åˆçº¦ã€‚ ç”¨æˆ·å¯ä»¥è®©é‚£ä¸ªåˆçº¦å°†ä»£å¸å‘é€åˆ°äº¤æ˜“æ‰€çš„é’±åŒ…åœ°å€ï¼Œç„¶åŽäº¤æ˜“æ‰€å¯ä»¥è®©åˆçº¦åœ¨ç”¨æˆ·è¦æ±‚å–æ¬¾æ—¶å°†ä»£å¸å‘é€å›žç»™ä»–ä»¬ã€‚

äº¤æ˜“æ‰€åªéœ€è¦å®žçŽ°è¿™ç§è½¬ç§»é€»è¾‘ä¸€æ¬¡ï¼Œç„¶åŽå½“å®ƒæƒ³è¦æ·»åŠ ä¸€ä¸ªæ–°çš„ ERC20 ä»£å¸æ—¶ï¼Œåªéœ€å°†æ–°çš„åˆçº¦åœ°å€æ·»åŠ åˆ°å®ƒçš„æ•°æ®åº“å³å¯ã€‚

**å…¶ä»–ä»£å¸æ ‡å‡†**
å¯¹äºŽåƒè´§å¸ä¸€æ ·çš„ä»£å¸æ¥è¯´ï¼ŒERC20 ä»£å¸éžå¸¸é…·ã€‚ ä½†æ˜¯è¦åœ¨æˆ‘ä»¬åƒµå°¸æ¸¸æˆä¸­ä»£è¡¨åƒµå°¸å°±å¹¶ä¸æ˜¯ç‰¹åˆ«æœ‰ç”¨ã€‚

é¦–å…ˆï¼Œåƒµå°¸ä¸åƒè´§å¸å¯ä»¥åˆ†å‰² â€”â€” æˆ‘å¯ä»¥å‘ç»™ä½  0.237 ä»¥å¤ªï¼Œä½†æ˜¯è½¬ç§»ç»™ä½  0.237 çš„åƒµå°¸å¬èµ·æ¥å°±æœ‰äº›æžç¬‘ã€‚

å…¶æ¬¡ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰åƒµå°¸éƒ½æ˜¯å¹³ç­‰çš„ã€‚ ä½ çš„2çº§åƒµå°¸"Steve"å®Œå…¨ä¸èƒ½ç­‰åŒäºŽæˆ‘732çº§çš„åƒµå°¸"H4XF13LD MORRIS ðŸ’¯ðŸ’¯ðŸ˜ŽðŸ’¯ðŸ’¯"ã€‚ï¼ˆä½ å·®å¾—è¿œå‘¢ï¼ŒSteveï¼‰ã€‚

æœ‰å¦ä¸€ä¸ªä»£å¸æ ‡å‡†æ›´é€‚åˆå¦‚ CryptoZombies è¿™æ ·çš„åŠ å¯†æ”¶è—å“â€”â€”å®ƒä»¬è¢«ç§°ä¸ºERC721 ä»£å¸.

ERC721 ä»£å¸æ˜¯ä¸èƒ½äº’æ¢çš„ï¼Œå› ä¸ºæ¯ä¸ªä»£å¸éƒ½è¢«è®¤ä¸ºæ˜¯å”¯ä¸€ä¸”ä¸å¯åˆ†å‰²çš„ã€‚ ä½ åªèƒ½ä»¥æ•´ä¸ªå•ä½äº¤æ˜“å®ƒä»¬ï¼Œå¹¶ä¸”æ¯ä¸ªå•ä½éƒ½æœ‰å”¯ä¸€çš„ IDã€‚ è¿™äº›ç‰¹æ€§æ­£å¥½è®©æˆ‘ä»¬çš„åƒµå°¸å¯ä»¥ç”¨æ¥äº¤æ˜“ã€‚

> è¯·æ³¨æ„ï¼Œä½¿ç”¨åƒ ERC721 è¿™æ ·çš„æ ‡å‡†çš„ä¼˜åŠ¿å°±æ˜¯ï¼Œæˆ‘ä»¬ä¸å¿…åœ¨æˆ‘ä»¬çš„åˆçº¦ä¸­å®žçŽ°æ‹å–æˆ–æ‰˜ç®¡é€»è¾‘ï¼Œè¿™å†³å®šäº†çŽ©å®¶èƒ½å¤Ÿå¦‚ä½•äº¤æ˜“ï¼å‡ºå”®æˆ‘ä»¬çš„åƒµå°¸ã€‚ å¦‚æžœæˆ‘ä»¬ç¬¦åˆè§„èŒƒï¼Œå…¶ä»–äººå¯ä»¥ä¸ºåŠ å¯†å¯äº¤æ˜“çš„ ERC721 èµ„äº§æ­å»ºä¸€ä¸ªäº¤æ˜“æ‰€å¹³å°ï¼Œæˆ‘ä»¬çš„ ERC721 åƒµå°¸å°†å¯ä»¥åœ¨è¯¥å¹³å°ä¸Šä½¿ç”¨ã€‚ æ‰€ä»¥ä½¿ç”¨ä»£å¸æ ‡å‡†ç›¸è¾ƒäºŽä½¿ç”¨ä½ è‡ªå·±çš„äº¤æ˜“é€»è¾‘æœ‰æ˜Žæ˜¾çš„å¥½å¤„ã€‚

å®žæˆ˜æ¼”ä¹ :
zombieownership.sol:
```
pragma solidity ^0.4.19;

import "./zombieattack.sol";

contract ZombieOwnership is ZombieAttack {
}
```
#### â‘¡ERC721 æ ‡å‡†, å¤šé‡ç»§æ‰¿
è®©æˆ‘ä»¬æ¥çœ‹ä¸€çœ‹ ERC721 æ ‡å‡†ï¼š
```
contract ERC721 {
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

  function balanceOf(address _owner) public view returns (uint256 _balance);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function transfer(address _to, uint256 _tokenId) public;
  function approve(address _to, uint256 _tokenId) public;
  function takeOwnership(uint256 _tokenId) public;
}
```
è¿™æ˜¯æˆ‘ä»¬éœ€è¦å®žçŽ°çš„æ–¹æ³•åˆ—è¡¨ï¼Œæˆ‘ä»¬å°†åœ¨æŽ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­é€ä¸ªå­¦ä¹ ã€‚

è™½ç„¶çœ‹èµ·æ¥å¾ˆå¤šï¼Œä½†ä¸è¦è¢«å“åˆ°äº†ï¼æˆ‘ä»¬åœ¨è¿™é‡Œå°±æ˜¯å‡†å¤‡å¸¦ç€ä½ ä¸€æ­¥ä¸€æ­¥äº†è§£å®ƒä»¬çš„ã€‚
> æ³¨æ„ï¼š ERC721ç›®å‰æ˜¯ä¸€ä¸ª è‰ç¨¿ï¼Œè¿˜æ²¡æœ‰æ­£å¼å•†å®šçš„å®žçŽ°ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ OpenZeppelin åº“ä¸­çš„å½“å‰ç‰ˆæœ¬ï¼Œä½†åœ¨æœªæ¥æ­£å¼å‘å¸ƒä¹‹å‰å®ƒå¯èƒ½ä¼šæœ‰æ›´æ”¹ã€‚ æ‰€ä»¥æŠŠè¿™ ä¸€ä¸ª å¯èƒ½çš„å®žçŽ°å½“ä½œè€ƒè™‘ï¼Œä½†ä¸è¦æŠŠå®ƒä½œä¸º ERC721 ä»£å¸çš„å®˜æ–¹æ ‡å‡†ã€‚

**å®žçŽ°ä¸€ä¸ªä»£å¸åˆçº¦**
åœ¨å®žçŽ°ä¸€ä¸ªä»£å¸åˆçº¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬é¦–å…ˆè¦åšçš„æ˜¯å°†æŽ¥å£å¤åˆ¶åˆ°å®ƒè‡ªå·±çš„ Solidity æ–‡ä»¶å¹¶å¯¼å…¥å®ƒï¼Œ`import "./erc721.sol";`ã€‚ æŽ¥ç€ï¼Œè®©æˆ‘ä»¬çš„åˆçº¦ç»§æ‰¿å®ƒï¼Œç„¶åŽæˆ‘ä»¬ç”¨ä¸€ä¸ªå‡½æ•°å®šä¹‰æ¥é‡å†™æ¯ä¸ªæ–¹æ³•ã€‚

ä½†ç­‰ä¸€ä¸‹â€”â€” `ZombieOwnership`å·²ç»ç»§æ‰¿è‡ª `ZombieAttack`äº† â€”â€” å®ƒå¦‚ä½•èƒ½å¤Ÿä¹Ÿç»§æ‰¿äºŽ `ERC721`å‘¢ï¼Ÿ

å¹¸è¿çš„æ˜¯åœ¨Solidityï¼Œä½ çš„åˆçº¦å¯ä»¥ç»§æ‰¿è‡ªå¤šä¸ªåˆçº¦ï¼Œå‚è€ƒå¦‚ä¸‹ï¼š
```
contract SatoshiNakamoto is NickSzabo, HalFinney {
  
}
```
æ­£å¦‚ä½ æ‰€è§ï¼Œå½“ä½¿ç”¨å¤šé‡ç»§æ‰¿çš„æ—¶å€™ï¼Œä½ åªéœ€è¦ç”¨é€—å· , æ¥éš”å¼€å‡ ä¸ªä½ æƒ³è¦ç»§æ‰¿çš„åˆçº¦ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬çš„åˆçº¦ç»§æ‰¿è‡ª `NickSzabo` å’Œ `HalFinney`ã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
```
pragma solidity ^0.4.19;

import "./zombieattack.sol";
import "./erc721.sol";

contract ZombieOwnership is ZombieAttack, ERC721 {

}
```
#### â‘¢balanceOf å’Œ ownerOf
åœ¨æœ¬ç« èŠ‚ï¼Œæˆ‘ä»¬å°†å®žçŽ°å¤´ä¸¤ä¸ªæ–¹æ³•ï¼š balanceOf å’Œ ownerOfã€‚

**balanceOf**
`function balanceOf(address _owner) public view returns (uint256 _balance);`
è¿™ä¸ªå‡½æ•°åªéœ€è¦ä¸€ä¸ªä¼ å…¥ address å‚æ•°ï¼Œç„¶åŽè¿”å›žè¿™ä¸ª address æ‹¥æœ‰å¤šå°‘ä»£å¸ã€‚

åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬çš„â€œä»£å¸â€æ˜¯åƒµå°¸ã€‚ä½ è¿˜è®°å¾—åœ¨æˆ‘ä»¬ DApp çš„å“ªé‡Œå­˜å‚¨äº†ä¸€ä¸ªä¸»äººæ‹¥æœ‰å¤šå°‘åªåƒµå°¸å—ï¼Ÿ

**ownerOf**

`function ownerOf(uint256 _tokenId) public view returns (address _owner);`
è¿™ä¸ªå‡½æ•°éœ€è¦ä¼ å…¥ä¸€ä¸ªä»£å¸ ID ä½œä¸ºå‚æ•° (æˆ‘ä»¬çš„æƒ…å†µå°±æ˜¯ä¸€ä¸ªåƒµå°¸ ID)ï¼Œç„¶åŽè¿”å›žè¯¥ä»£å¸æ‹¥æœ‰è€…çš„ addressã€‚

åŒæ ·çš„ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬çš„ DApp é‡Œå·²ç»æœ‰ä¸€ä¸ª mapping (æ˜ å°„) å­˜å‚¨äº†è¿™ä¸ªä¿¡æ¯ï¼Œæ‰€ä»¥å¯¹æˆ‘ä»¬æ¥è¯´è¿™ä¸ªå®žçŽ°éžå¸¸ç›´æŽ¥æ¸…æ™°ã€‚æˆ‘ä»¬å¯ä»¥åªç”¨ä¸€è¡Œ return è¯­å¥æ¥å®žçŽ°è¿™ä¸ªå‡½æ•°ã€‚

> æ³¨æ„ï¼šè¦è®°å¾—ï¼Œ uint256 ç­‰åŒäºŽuintã€‚æˆ‘ä»¬ä»Žè¯¾ç¨‹çš„å¼€å§‹ä¸€ç›´åœ¨ä»£ç ä¸­ä½¿ç”¨ uintï¼Œä½†ä»ŽçŽ°åœ¨å¼€å§‹æˆ‘ä»¬å°†åœ¨è¿™é‡Œç”¨ uint256ï¼Œå› ä¸ºæˆ‘ä»¬ç›´æŽ¥ä»Žè§„èŒƒä¸­å¤åˆ¶ç²˜è´´ã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
```
  function balanceOf(address _owner) public view returns (uint256 _balance) {
    return ownerZombieCount[_owner];
  }

  function ownerOf(uint256 _tokenId) public view returns (address _owner) {
    return zombieToOwner[_tokenId];
  }
```
#### â‘£é‡æž„
æˆ‘ä»¬åˆšåˆšçš„ä»£ç ä¸­å…¶å®žæœ‰ä¸ªé”™è¯¯ï¼Œä»¥è‡³äºŽå…¶æ ¹æœ¬æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œä½ å‘çŽ°äº†æ²¡ï¼Ÿ

åœ¨å‰ä¸€ä¸ªç« èŠ‚æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå« ownerOf çš„å‡½æ•°ã€‚ä½†å¦‚æžœä½ è¿˜è®°å¾—ç¬¬4è¯¾çš„å†…å®¹ï¼Œæˆ‘ä»¬åŒæ ·åœ¨zombiefeeding.sol é‡Œä»¥ ownerOf å‘½ååˆ›å»ºäº†ä¸€ä¸ª modifierï¼ˆä¿®é¥°ç¬¦ï¼‰ã€‚

å¦‚æžœä½ å°è¯•ç¼–è¯‘è¿™æ®µä»£ç ï¼Œç¼–è¯‘å™¨ä¼šç»™ä½ ä¸€ä¸ªé”™è¯¯è¯´ä½ ä¸èƒ½æœ‰ç›¸åŒåç§°çš„ä¿®é¥°ç¬¦å’Œå‡½æ•°ã€‚

æ‰€ä»¥æˆ‘ä»¬åº”è¯¥æŠŠåœ¨ ZombieOwnership é‡Œçš„å‡½æ•°åç§°æ”¹æˆåˆ«çš„å—ï¼Ÿ

ä¸ï¼Œæˆ‘ä»¬ä¸èƒ½é‚£æ ·åšï¼ï¼ï¼è¦è®°å¾—ï¼Œæˆ‘ä»¬æ­£åœ¨ç”¨ ERC721 ä»£å¸æ ‡å‡†ï¼Œæ„å‘³ç€å…¶ä»–åˆçº¦å°†æœŸæœ›æˆ‘ä»¬çš„åˆçº¦ä»¥è¿™äº›ç¡®åˆ‡çš„åç§°æ¥å®šä¹‰å‡½æ•°ã€‚è¿™å°±æ˜¯è¿™äº›æ ‡å‡†å®žç”¨çš„åŽŸå› â€”â€”å¦‚æžœå¦ä¸€ä¸ªåˆçº¦çŸ¥é“æˆ‘ä»¬çš„åˆçº¦ç¬¦åˆ ERC721 æ ‡å‡†ï¼Œå®ƒå¯ä»¥ç›´æŽ¥ä¸Žæˆ‘ä»¬äº¤äº’ï¼Œè€Œæ— éœ€äº†è§£ä»»ä½•å…³äºŽæˆ‘ä»¬å†…éƒ¨å¦‚ä½•å®žçŽ°çš„ç»†èŠ‚ã€‚

æ‰€ä»¥ï¼Œé‚£æ„å‘³ç€æˆ‘ä»¬å°†å¿…é¡»é‡æž„æˆ‘ä»¬ç¬¬4è¯¾ä¸­çš„ä»£ç ï¼Œå°† modifier çš„åç§°æ¢æˆåˆ«çš„ã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
æˆ‘ä»¬å›žåˆ°äº† zombiefeeding.sol ã€‚æˆ‘ä»¬å°†æŠŠ modifier çš„åç§°ä»Ž ownerOf æ”¹æˆ onlyOwnerOfã€‚

1. æŠŠä¿®é¥°ç¬¦å®šä¹‰ä¸­çš„åç§°æ”¹æˆ onlyOwnerOf

2. å¾€ä¸‹æ»‘åˆ°ä½¿ç”¨æ­¤ä¿®é¥°ç¬¦çš„å‡½æ•° feedAndMultiply ã€‚æˆ‘ä»¬ä¹Ÿéœ€è¦æ”¹è¿™é‡Œçš„åç§°ã€‚

> æ³¨æ„ï¼šæˆ‘ä»¬åœ¨ zombiehelper.sol å’Œ zombieattack.sol é‡Œä¹Ÿä½¿ç”¨äº†è¿™ä¸ªä¿®é¥°ç¬¦ï¼Œä½†ä¸ºäº†ä¸åœ¨è¿™èŠ‚è¯¾çš„é‡æž„é‡ŒèŠ±å¤ªå¤šæ—¶é—´ï¼Œæˆ‘ä»¬å·²ç»å°†é‚£äº›æ–‡ä»¶é‡Œçš„ä¿®é¥°ç¬¦åç§°ä¸ºä½ æ”¹å¥½äº†ã€‚
#### â‘¤ERC721: è½¬ç§»æ ‡å‡†
çŽ°åœ¨æˆ‘ä»¬å°†é€šè¿‡å­¦ä¹ æŠŠæ‰€æœ‰æƒä»Žä¸€ä¸ªäººè½¬ç§»ç»™å¦ä¸€ä¸ªäººæ¥ç»§ç»­æˆ‘ä»¬çš„ ERC721 è§„èŒƒçš„å®žçŽ°ã€‚

æ³¨æ„ ERC721 è§„èŒƒæœ‰ä¸¤ç§ä¸åŒçš„æ–¹æ³•æ¥è½¬ç§»ä»£å¸ï¼š
```
function transfer(address _to, uint256 _tokenId) public;

function approve(address _to, uint256 _tokenId) public;
function takeOwnership(uint256 _tokenId) public;
```
1. ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ä»£å¸çš„æ‹¥æœ‰è€…è°ƒç”¨transfer æ–¹æ³•ï¼Œä¼ å…¥ä»–æƒ³è½¬ç§»åˆ°çš„ address å’Œä»–æƒ³è½¬ç§»çš„ä»£å¸çš„ _tokenIdã€‚

2. ç¬¬äºŒç§æ–¹æ³•æ˜¯ä»£å¸æ‹¥æœ‰è€…é¦–å…ˆè°ƒç”¨ approveï¼Œç„¶åŽä¼ å…¥ä¸Žä»¥ä¸Šç›¸åŒçš„å‚æ•°ã€‚æŽ¥ç€ï¼Œè¯¥åˆçº¦ä¼šå­˜å‚¨è°è¢«å…è®¸æå–ä»£å¸ï¼Œé€šå¸¸å­˜å‚¨åˆ°ä¸€ä¸ª mapping (uint256 => address) é‡Œã€‚ç„¶åŽï¼Œå½“æœ‰äººè°ƒç”¨ takeOwnership æ—¶ï¼Œåˆçº¦ä¼šæ£€æŸ¥ msg.sender æ˜¯å¦å¾—åˆ°æ‹¥æœ‰è€…çš„æ‰¹å‡†æ¥æå–ä»£å¸ï¼Œå¦‚æžœæ˜¯ï¼Œåˆ™å°†ä»£å¸è½¬ç§»ç»™ä»–ã€‚

ä½ æ³¨æ„åˆ°äº†å—ï¼Œtransfer å’Œ takeOwnership éƒ½å°†åŒ…å«ç›¸åŒçš„è½¬ç§»é€»è¾‘ï¼Œåªæ˜¯ä»¥ç›¸åçš„é¡ºåºã€‚ ï¼ˆä¸€ç§æƒ…å†µæ˜¯ä»£å¸çš„å‘é€è€…è°ƒç”¨å‡½æ•°ï¼›å¦ä¸€ç§æƒ…å†µæ˜¯ä»£å¸çš„æŽ¥æ”¶è€…è°ƒç”¨å®ƒï¼‰ã€‚

æ‰€ä»¥æˆ‘ä»¬æŠŠè¿™ä¸ªé€»è¾‘æŠ½è±¡æˆå®ƒè‡ªå·±çš„ç§æœ‰å‡½æ•° _transferï¼Œç„¶åŽç”±è¿™ä¸¤ä¸ªå‡½æ•°æ¥è°ƒç”¨å®ƒã€‚ è¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨å†™é‡å¤çš„ä»£ç äº†ã€‚

å®žæˆ˜æ¼”ä¹ :
```
function _transfer(address _from, address _to, uint256 _tokenId) private {
    ownerZombieCount[_to]++;
    ownerZombieCount[_from]--;
    zombieToOwner[_tokenId] = _to;
    Transfer(_from, _to, _tokenId);
  }
```
#### â‘¥ERC721: è½¬ç§»-ç»­
å®žæˆ˜æ¼”ä¹ ï¼š
```
function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    _transfer(msg.sender, _to, _tokenId);
  }
```
#### â‘¦ERC721: æ‰¹å‡†
çŽ°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å®žçŽ° approveã€‚

è®°ä½ï¼Œä½¿ç”¨ approve æˆ–è€… takeOwnership çš„æ—¶å€™ï¼Œè½¬ç§»æœ‰2ä¸ªæ­¥éª¤ï¼š

1. ä½ ï¼Œä½œä¸ºæ‰€æœ‰è€…ï¼Œç”¨æ–°ä¸»äººçš„ address å’Œä½ å¸Œæœ›ä»–èŽ·å–çš„ _tokenId æ¥è°ƒç”¨ approve

2. æ–°ä¸»äººç”¨ _tokenId æ¥è°ƒç”¨ takeOwnershipï¼Œåˆçº¦ä¼šæ£€æŸ¥ç¡®ä¿ä»–èŽ·å¾—äº†æ‰¹å‡†ï¼Œç„¶åŽæŠŠä»£å¸è½¬ç§»ç»™ä»–ã€‚

å› ä¸ºè¿™å‘ç”Ÿåœ¨2ä¸ªå‡½æ•°çš„è°ƒç”¨ä¸­ï¼Œæ‰€ä»¥åœ¨å‡½æ•°è°ƒç”¨ä¹‹é—´ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°æ®ç»“æž„æ¥å­˜å‚¨ä»€ä¹ˆäººè¢«æ‰¹å‡†èŽ·å–ä»€ä¹ˆã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
```
mapping (uint => address) zombieApprovals;

function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    zombieApprovals[_tokenId] = _to;
    Approval(msg.sender, _to, _tokenId);
  }
```
#### â‘§ERC721: takeOwnership
æœ€åŽä¸€ä¸ªå‡½æ•° takeOwnershipï¼Œ åº”è¯¥åªæ˜¯ç®€å•åœ°æ£€æŸ¥ä»¥ç¡®ä¿ msg.sender å·²ç»è¢«æ‰¹å‡†æ¥æå–è¿™ä¸ªä»£å¸æˆ–è€…åƒµå°¸ã€‚è‹¥ç¡®è®¤ï¼Œå°±è°ƒç”¨ _transferï¼›

å®žæˆ˜æ¼”ä¹ ï¼š
```
function takeOwnership(uint256 _tokenId) public {
    require(zombieApprovals[_tokenId] == msg.sender);
    address owner = ownerOf(_tokenId);
    _transfer(owner, msg.sender, _tokenId);
  }
```
#### â‘¨é¢„é˜²æº¢å‡º
æˆ‘ä»¬å®Œæˆäº† ERC721 çš„å®žçŽ°ã€‚

ä¸è¿‡è¦è®°ä½é‚£åªæ˜¯æœ€ç®€å•çš„å®žçŽ°ã€‚è¿˜æœ‰å¾ˆå¤šçš„ç‰¹æ€§æˆ‘ä»¬ä¹Ÿè®¸æƒ³åŠ å…¥åˆ°æˆ‘ä»¬çš„å®žçŽ°ä¸­æ¥ï¼Œæ¯”å¦‚ä¸€äº›é¢å¤–çš„æ£€æŸ¥ï¼Œæ¥ç¡®ä¿ç”¨æˆ·ä¸ä¼šä¸å°å¿ƒæŠŠä»–ä»¬çš„åƒµå°¸è½¬ç§»ç»™0 åœ°å€ï¼ˆè¿™è¢«ç§°ä½œ â€œçƒ§å¸â€, åŸºæœ¬ä¸Šå°±æ˜¯æŠŠä»£å¸è½¬ç§»åˆ°ä¸€ä¸ªè°ä¹Ÿæ²¡æœ‰ç§é’¥çš„åœ°å€ï¼Œè®©è¿™ä¸ªä»£å¸æ°¸è¿œä¹Ÿæ— æ³•æ¢å¤ï¼‰ã€‚ æˆ–è€…åœ¨ DApp ä¸­åŠ å…¥ä¸€äº›åŸºæœ¬çš„æ‹å–é€»è¾‘ã€‚ï¼ˆä½ èƒ½æƒ³å‡ºä¸€äº›å®žçŽ°çš„æ–¹æ³•ä¹ˆï¼Ÿï¼‰

ä½†æ˜¯ä¸ºäº†è®©æˆ‘ä»¬çš„è¯¾ç¨‹ä¸è‡³äºŽç¦»é¢˜å¤ªè¿œï¼Œæ‰€ä»¥æˆ‘ä»¬åªä¸“æ³¨äºŽä¸€äº›åŸºç¡€å®žçŽ°ã€‚å¦‚æžœä½ æƒ³å­¦ä¹ ä¸€äº›æ›´æ·±å±‚æ¬¡çš„å®žçŽ°ï¼Œå¯ä»¥åœ¨è¿™ä¸ªæ•™ç¨‹ç»“æŸåŽï¼ŒåŽ»çœ‹çœ‹ OpenZeppelin çš„ ERC721 åˆçº¦ã€‚

**åˆçº¦å®‰å…¨å¢žå¼º: æº¢å‡ºå’Œä¸‹æº¢**
æˆ‘ä»¬å°†æ¥å­¦ä¹ ä½ åœ¨ç¼–å†™æ™ºèƒ½åˆçº¦çš„æ—¶å€™éœ€è¦æ³¨æ„çš„ä¸€ä¸ªä¸»è¦çš„å®‰å…¨ç‰¹æ€§ï¼šé˜²æ­¢æº¢å‡ºå’Œä¸‹æº¢ã€‚

ä»€ä¹ˆæ˜¯ _æº¢å‡º_ (overflow)?

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª uint8, åªèƒ½å­˜å‚¨8 bitæ•°æ®ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬èƒ½å­˜å‚¨çš„æœ€å¤§æ•°å­—å°±æ˜¯äºŒè¿›åˆ¶ 11111111 (æˆ–è€…è¯´åè¿›åˆ¶çš„ 2^8 - 1 = 255).

æ¥çœ‹çœ‹ä¸‹é¢çš„ä»£ç ã€‚æœ€åŽ number å°†ä¼šæ˜¯ä»€ä¹ˆå€¼ï¼Ÿ
```
uint8 number = 255;
number++;
```
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¯¼è‡´äº†æº¢å‡º â€” è™½ç„¶æˆ‘ä»¬åŠ äº†1ï¼Œ ä½†æ˜¯ number å‡ºä¹Žæ„æ–™åœ°ç­‰äºŽ 0äº†ã€‚ (å¦‚æžœä½ ç»™äºŒè¿›åˆ¶ 11111111 åŠ 1, å®ƒå°†è¢«é‡ç½®ä¸º 00000000ï¼Œå°±åƒé’Ÿè¡¨ä»Ž 23:59 èµ°å‘ 00:00)ã€‚

ä¸‹æº¢(underflow)ä¹Ÿç±»ä¼¼ï¼Œå¦‚æžœä½ ä»Žä¸€ä¸ªç­‰äºŽ 0 çš„ uint8 å‡åŽ» 1, å®ƒå°†å˜æˆ 255 (å› ä¸º uint æ˜¯æ— ç¬¦å·çš„ï¼Œå…¶ä¸èƒ½ç­‰äºŽè´Ÿæ•°)ã€‚

è™½ç„¶æˆ‘ä»¬åœ¨è¿™é‡Œä¸ä½¿ç”¨ uint8ï¼Œè€Œä¸”æ¯æ¬¡ç»™ä¸€ä¸ª uint256 åŠ  1 ä¹Ÿä¸å¤ªå¯èƒ½æº¢å‡º (2^256 çœŸçš„æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ•°äº†)ï¼Œåœ¨æˆ‘ä»¬çš„åˆçº¦ä¸­æ·»åŠ ä¸€äº›ä¿æŠ¤æœºåˆ¶ä¾ç„¶æ˜¯éžå¸¸æœ‰å¿…è¦çš„ï¼Œä»¥é˜²æˆ‘ä»¬çš„ DApp ä»¥åŽå‡ºçŽ°ä»€ä¹ˆå¼‚å¸¸æƒ…å†µã€‚

**ä½¿ç”¨ SafeMath**
ä¸ºäº†é˜²æ­¢è¿™äº›æƒ…å†µï¼ŒOpenZeppelin å»ºç«‹äº†ä¸€ä¸ªå«åš SafeMath çš„ _åº“_(library)ï¼Œé»˜è®¤æƒ…å†µä¸‹å¯ä»¥é˜²æ­¢è¿™äº›é—®é¢˜ã€‚

ä¸è¿‡åœ¨æˆ‘ä»¬ä½¿ç”¨ä¹‹å‰â€¦â€¦ ä»€ä¹ˆå«åšåº“?

ä¸€ä¸ª_åº“_ æ˜¯ Solidity ä¸­ä¸€ç§ç‰¹æ®Šçš„åˆçº¦ã€‚å…¶ä¸­ä¸€ä¸ªæœ‰ç”¨çš„åŠŸèƒ½æ˜¯ç»™åŽŸå§‹æ•°æ®ç±»åž‹å¢žåŠ ä¸€äº›æ–¹æ³•ã€‚

æ¯”å¦‚ï¼Œä½¿ç”¨ SafeMath åº“çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ using SafeMath for uint256 è¿™æ ·çš„è¯­æ³•ã€‚ SafeMath åº“æœ‰å››ä¸ªæ–¹æ³• â€” addï¼Œ subï¼Œ mulï¼Œ ä»¥åŠ divã€‚çŽ°åœ¨æˆ‘ä»¬å¯ä»¥è¿™æ ·æ¥è®© uint256 è°ƒç”¨è¿™äº›æ–¹æ³•ï¼š
```
using SafeMath for uint256;

uint256 a = 5;
uint256 b = a.add(3); // 5 + 3 = 8
uint256 c = a.mul(2); // 5 * 2 = 10
```
æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« æ¥å­¦ä¹ è¿™äº›æ–¹æ³•ï¼Œä¸è¿‡çŽ°åœ¨æˆ‘ä»¬å…ˆå°† SafeMath åº“æ·»åŠ è¿›æˆ‘ä»¬çš„åˆçº¦ã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
1. å°† safemath.sol å¼•å…¥åˆ° zombiefactory.sol.
2. æ·»åŠ å®šä¹‰ï¼š using SafeMath for uint256;.
#### â‘©SafeMathç¬¬äºŒéƒ¨åˆ†
æ¥çœ‹çœ‹ SafeMath çš„éƒ¨åˆ†ä»£ç :
```
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```
é¦–å…ˆæˆ‘ä»¬æœ‰äº† library å…³é”®å­— â€” åº“å’Œ åˆçº¦å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯åˆæœ‰ä¸€äº›ä¸åŒã€‚ å°±æˆ‘ä»¬çš„ç›®çš„è€Œè¨€ï¼Œåº“å…è®¸æˆ‘ä»¬ä½¿ç”¨ using å…³é”®å­—ï¼Œå®ƒå¯ä»¥è‡ªåŠ¨æŠŠåº“çš„æ‰€æœ‰æ–¹æ³•æ·»åŠ ç»™ä¸€ä¸ªæ•°æ®ç±»åž‹ï¼š
```
using SafeMath for uint;
// è¿™ä¸‹æˆ‘ä»¬å¯ä»¥ä¸ºä»»ä½• uint è°ƒç”¨è¿™äº›æ–¹æ³•äº†
uint test = 2;
test = test.mul(3); // test ç­‰äºŽ 6 äº†
test = test.add(5); // test ç­‰äºŽ 11 äº†
```
æ³¨æ„ mul å’Œ add å…¶å®žéƒ½éœ€è¦ä¸¤ä¸ªå‚æ•°ã€‚ åœ¨æˆ‘ä»¬å£°æ˜Žäº† using SafeMath for uint åŽï¼Œæˆ‘ä»¬ç”¨æ¥è°ƒç”¨è¿™äº›æ–¹æ³•çš„ uint å°±è‡ªåŠ¨è¢«ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’è¿›åŽ»äº†(åœ¨æ­¤ä¾‹ä¸­å°±æ˜¯ test)

æˆ‘ä»¬æ¥çœ‹çœ‹ add çš„æºä»£ç çœ‹ SafeMath åšäº†ä»€ä¹ˆ:
```
function add(uint256 a, uint256 b) internal pure returns (uint256) {
  uint256 c = a + b;
  assert(c >= a);
  return c;
}
```
åŸºæœ¬ä¸Š add åªæ˜¯åƒ + ä¸€æ ·å¯¹ä¸¤ä¸ª uint ç›¸åŠ ï¼Œ ä½†æ˜¯å®ƒç”¨ä¸€ä¸ª assert è¯­å¥æ¥ç¡®ä¿ç»“æžœå¤§äºŽ aã€‚è¿™æ ·å°±é˜²æ­¢äº†æº¢å‡ºã€‚

assert å’Œ require ç›¸ä¼¼ï¼Œè‹¥ç»“æžœä¸ºå¦å®ƒå°±ä¼šæŠ›å‡ºé”™è¯¯ã€‚ assert å’Œ require åŒºåˆ«åœ¨äºŽï¼Œrequire è‹¥å¤±è´¥åˆ™ä¼šè¿”è¿˜ç»™ç”¨æˆ·å‰©ä¸‹çš„ gasï¼Œ assert åˆ™ä¸ä¼šã€‚æ‰€ä»¥å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œä½ å†™ä»£ç çš„æ—¶å€™ä¼šæ¯”è¾ƒå–œæ¬¢ requireï¼Œassert åªåœ¨ä»£ç å¯èƒ½å‡ºçŽ°ä¸¥é‡é”™è¯¯çš„æ—¶å€™ä½¿ç”¨ï¼Œæ¯”å¦‚ uint æº¢å‡ºã€‚

æ‰€ä»¥ç®€è€Œè¨€ä¹‹ï¼Œ SafeMath çš„ addï¼Œ subï¼Œ mulï¼Œ å’Œ div æ–¹æ³•åªåšç®€å•çš„å››åˆ™è¿ç®—ï¼Œç„¶åŽåœ¨å‘ç”Ÿæº¢å‡ºæˆ–ä¸‹æº¢çš„æ—¶å€™æŠ›å‡ºé”™è¯¯ã€‚

**åœ¨æˆ‘ä»¬çš„ä»£ç é‡Œä½¿ç”¨ SafeMathã€‚**
ä¸ºäº†é˜²æ­¢æº¢å‡ºå’Œä¸‹æº¢ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æˆ‘ä»¬çš„ä»£ç é‡Œæ‰¾ +ï¼Œ -ï¼Œ *ï¼Œ æˆ– /ï¼Œç„¶åŽæ›¿æ¢ä¸º add, sub, mul, div.

æ¯”å¦‚ï¼Œä¸Žå…¶è¿™æ ·åš:`myUint++;`
æˆ‘ä»¬è¿™æ ·åš:`myUint = myUint.add(1);`

å®žæˆ˜æ¼”ä¹ ï¼š
    // 1. æ›¿æ¢æˆ SafeMath çš„ `add`
    ownerZombieCount[_to]++;
    // 2. æ›¿æ¢æˆ SafeMath çš„ `sub`
    ownerZombieCount[_from]--;
```
    ownerZombieCount[_to] = ownerZombieCount[_to].add(1);
    ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);
```
#### â‘ªSafeMath ç¬¬ä¸‰éƒ¨åˆ†
å¤ªå¥½äº†ï¼Œè¿™ä¸‹æˆ‘ä»¬çš„ ERC721 å®žçŽ°ä¸ä¼šæœ‰æº¢å‡ºæˆ–è€…ä¸‹æº¢äº†ã€‚

å›žå¤´çœ‹çœ‹æˆ‘ä»¬åœ¨ä¹‹å‰è¯¾ç¨‹å†™çš„ä»£ç ï¼Œè¿˜æœ‰å…¶ä»–å‡ ä¸ªåœ°æ–¹ä¹Ÿæœ‰å¯èƒ½å¯¼è‡´æº¢å‡ºæˆ–ä¸‹æº¢ã€‚

æ¯”å¦‚ï¼Œ åœ¨ ZombieAttack é‡Œé¢æˆ‘ä»¬æœ‰ï¼š
```
myZombie.winCount++;
myZombie.level++;
enemyZombie.lossCount++;
```
æˆ‘ä»¬åŒæ ·åº”è¯¥åœ¨è¿™äº›åœ°æ–¹é˜²æ­¢æº¢å‡ºã€‚ï¼ˆé€šå¸¸æƒ…å†µä¸‹ï¼Œæ€»æ˜¯ä½¿ç”¨ SafeMath è€Œä¸æ˜¯æ™®é€šæ•°å­¦è¿ç®—æ˜¯ä¸ªå¥½ä¸»æ„ï¼Œä¹Ÿè®¸åœ¨ä»¥åŽ Solidity çš„æ–°ç‰ˆæœ¬é‡Œè¿™ç‚¹ä¼šè¢«é»˜è®¤å®žçŽ°ï¼Œä½†æ˜¯çŽ°åœ¨æˆ‘ä»¬å¾—è‡ªå·±åœ¨ä»£ç é‡Œå®žçŽ°è¿™äº›é¢å¤–çš„å®‰å…¨æŽªæ–½ï¼‰ã€‚

ä¸è¿‡æˆ‘ä»¬é‡åˆ°ä¸ªå°é—®é¢˜ â€” winCount å’Œ lossCount æ˜¯ uint16ï¼Œ è€Œ level æ˜¯ uint32ã€‚ æ‰€ä»¥å¦‚æžœæˆ‘ä»¬ç”¨è¿™äº›ä½œä¸ºå‚æ•°ä¼ å…¥ SafeMath çš„ add æ–¹æ³•ã€‚ å®ƒå®žé™…ä¸Šå¹¶ä¸ä¼šé˜²æ­¢æº¢å‡ºï¼Œå› ä¸ºå®ƒä¼šæŠŠè¿™äº›å˜é‡éƒ½è½¬æ¢æˆ uint256:
```
function add(uint256 a, uint256 b) internal pure returns (uint256) {
  uint256 c = a + b;
  assert(c >= a);
  return c;
}

// å¦‚æžœæˆ‘ä»¬åœ¨`uint8` ä¸Šè°ƒç”¨ `.add`ã€‚å®ƒå°†ä¼šè¢«è½¬æ¢æˆ `uint256`.
// æ‰€ä»¥å®ƒä¸ä¼šåœ¨ 2^8 æ—¶æº¢å‡ºï¼Œå› ä¸º 256 æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ `uint256`.
```
è¿™å°±æ„å‘³ç€ï¼Œæˆ‘ä»¬éœ€è¦å†å®žçŽ°ä¸¤ä¸ªåº“æ¥é˜²æ­¢ uint16 å’Œ uint32 æº¢å‡ºæˆ–ä¸‹æº¢ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶å‘½åä¸º SafeMath16 å’Œ SafeMath32ã€‚

ä»£ç å°†å’Œ SafeMath å®Œå…¨ç›¸åŒï¼Œé™¤äº†æ‰€æœ‰çš„ uint256 å®žä¾‹éƒ½å°†è¢«æ›¿æ¢æˆ uint32 æˆ– uint16ã€‚

æˆ‘ä»¬å·²ç»å°†è¿™äº›ä»£ç å¸®ä½ å†™å¥½äº†ï¼Œæ‰“å¼€ safemath.sol åˆçº¦çœ‹çœ‹ä»£ç å§ã€‚

çŽ°åœ¨æˆ‘ä»¬éœ€è¦åœ¨ ZombieFactory é‡Œä½¿ç”¨å®ƒä»¬ã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
```
  using SafeMath for uint256;
  using SafeMath32 for uint32;
  using SafeMath16 for uint16;
```
#### â‘«SafeMath ç¬¬4éƒ¨åˆ†
çœŸæ£’ï¼ŒçŽ°åœ¨æˆ‘ä»¬å·²ç»ä¸ºæˆ‘ä»¬çš„ DApp é‡Œé¢ç”¨åˆ°çš„ uint æ•°æ®ç±»åž‹éƒ½å®žçŽ°äº† SafeMath äº†ã€‚

è®©æˆ‘ä»¬æŠŠ ZombieAttack é‡Œæ‰€æœ‰æ½œåœ¨çš„é—®é¢˜éƒ½ä¿®å¤äº†å§ã€‚ ï¼ˆå…¶å®žåœ¨ ZombieHelper é‡Œä¹Ÿæœ‰ä¸€å¤„ zombies[_zombieId].level++; éœ€è¦ä¿®å¤ï¼Œä¸è¿‡æˆ‘ä»¬å·²ç»å¸®ä½ åšå¥½äº†ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨å†æ¥ä¸€ç« äº† ðŸ˜‰ï¼‰ã€‚
#### â‘¬æ³¨é‡Š
åƒµå°¸æ¸¸æˆçš„ Solidity ä»£ç ç»ˆäºŽå®Œæˆå•¦ã€‚

åœ¨ä»¥åŽçš„è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å°†æ¸¸æˆéƒ¨ç½²åˆ°ä»¥å¤ªåŠï¼Œä»¥åŠå¦‚ä½•å’Œ Web3.js äº¤äº’ã€‚

ä¸è¿‡åœ¨ä½ ç¦»å¼€ç¬¬äº”è¯¾ä¹‹å‰ï¼Œæˆ‘ä»¬æ¥è°ˆè°ˆå¦‚ä½• ç»™ä½ çš„ä»£ç æ·»åŠ æ³¨é‡Š.

**æ³¨é‡Šè¯­æ³•**
Solidity é‡Œçš„æ³¨é‡Šå’Œ JavaScript ç›¸åŒã€‚åœ¨æˆ‘ä»¬çš„è¯¾ç¨‹ä¸­ä½ å·²ç»çœ‹åˆ°äº†ä¸å°‘å•è¡Œæ³¨é‡Šäº†ï¼š

`// è¿™æ˜¯ä¸€ä¸ªå•è¡Œæ³¨é‡Šï¼Œå¯ä»¥ç†è§£ä¸ºç»™è‡ªå·±æˆ–è€…åˆ«äººçœ‹çš„ç¬”è®°`

åªè¦åœ¨ä»»ä½•åœ°æ–¹æ·»åŠ ä¸€ä¸ª // å°±æ„å‘³ç€ä½ åœ¨æ³¨é‡Šã€‚å¦‚æ­¤ç®€å•æ‰€ä»¥ä½ åº”è¯¥ç»å¸¸è¿™ä¹ˆåšã€‚

ä¸è¿‡æˆ‘ä»¬ä¹ŸçŸ¥é“ä½ çš„æƒ³æ³•ï¼šæœ‰æ—¶å€™å•è¡Œæ³¨é‡Šæ˜¯ä¸å¤Ÿçš„ã€‚æ¯•ç«Ÿä½ ç”Ÿæ¥è¯ç—¨ã€‚

æ‰€ä»¥æˆ‘ä»¬æœ‰äº†å¤šè¡Œæ³¨é‡Šï¼š
```
contract CryptoZombies {
  /* è¿™æ˜¯ä¸€ä¸ªå¤šè¡Œæ³¨é‡Šã€‚æˆ‘æƒ³å¯¹æ‰€æœ‰èŠ±æ—¶é—´æ¥å°è¯•è¿™ä¸ªç¼–ç¨‹è¯¾ç¨‹çš„äººè¯´å£°è°¢è°¢ã€‚
  å®ƒæ˜¯å…è´¹çš„ï¼Œå¹¶å°†æ°¸è¿œå…è´¹ã€‚ä½†æ˜¯æˆ‘ä»¬ä¾ç„¶å€¾æ³¨äº†æˆ‘ä»¬çš„å¿ƒè¡€æ¥è®©å®ƒå˜å¾—æ›´å¥½ã€‚

   è¦çŸ¥é“è¿™ä¾ç„¶åªæ˜¯åŒºå—é“¾å¼€å‘çš„å¼€å§‹è€Œå·²ï¼Œè™½ç„¶æˆ‘ä»¬å·²ç»èµ°äº†å¾ˆè¿œï¼Œ
   ä»ç„¶æœ‰å¾ˆå¤šç§æ–¹å¼æ¥è®©æˆ‘ä»¬çš„ç¤¾åŒºå˜å¾—æ›´å¥½ã€‚
   å¦‚æžœæˆ‘ä»¬åœ¨å“ªä¸ªåœ°æ–¹å‡ºäº†é”™ï¼Œæ¬¢è¿Žåœ¨æˆ‘ä»¬çš„ github æäº¤ PR æˆ–è€… issue æ¥å¸®åŠ©æˆ‘ä»¬æ”¹è¿›ï¼š
    https://github.com/loomnetwork/cryptozombie-lessons

    æˆ–è€…ï¼Œå¦‚æžœä½ æœ‰ä»»ä½•çš„æƒ³æ³•ã€å»ºè®®ç”šè‡³ä»…ä»…æƒ³å’Œæˆ‘ä»¬æ‰“å£°æ‹›å‘¼ï¼Œæ¬¢è¿Žæ¥æˆ‘ä»¬çš„ç”µæŠ¥ç¾¤ï¼š
     https://t.me/loomnetworkdev
  */
}
```
ç‰¹åˆ«æ˜¯ï¼Œæœ€å¥½ä¸ºä½ åˆçº¦ä¸­æ¯ä¸ªæ–¹æ³•æ·»åŠ æ³¨é‡Šæ¥è§£é‡Šå®ƒçš„é¢„æœŸè¡Œä¸ºã€‚è¿™æ ·å…¶ä»–å¼€å‘è€…ï¼ˆæˆ–è€…ä½ è‡ªå·±ï¼Œåœ¨6ä¸ªæœˆä»¥åŽå†å›žåˆ°è¿™ä¸ªé¡¹ç›®ä¸­ï¼‰å¯ä»¥å¾ˆå¿«åœ°ç†è§£ä½ çš„ä»£ç è€Œä¸éœ€è¦é€è¡Œé˜…è¯»æ‰€æœ‰ä»£ç ã€‚

Solidity ç¤¾åŒºæ‰€ä½¿ç”¨çš„ä¸€ä¸ªæ ‡å‡†æ˜¯ä½¿ç”¨ä¸€ç§è¢«ç§°ä½œ natspec çš„æ ¼å¼ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·ï¼š
```
/// @title ä¸€ä¸ªç®€å•çš„åŸºç¡€è¿ç®—åˆçº¦
/// @author H4XF13LD MORRIS ðŸ’¯ðŸ’¯ðŸ˜ŽðŸ’¯ðŸ’¯
/// @notice çŽ°åœ¨ï¼Œè¿™ä¸ªåˆçº¦åªæ·»åŠ ä¸€ä¸ªä¹˜æ³•
contract Math {
  /// @notice ä¸¤ä¸ªæ•°ç›¸ä¹˜
  /// @param x ç¬¬ä¸€ä¸ª uint
  /// @param y  ç¬¬äºŒä¸ª uint
  /// @return z  (x * y) çš„ç»“æžœ
  /// @dev çŽ°åœ¨è¿™ä¸ªæ–¹æ³•ä¸æ£€æŸ¥æº¢å‡º
  function multiply(uint x, uint y) returns (uint z) {
    // è¿™åªæ˜¯ä¸ªæ™®é€šçš„æ³¨é‡Šï¼Œä¸ä¼šè¢« natspec è§£é‡Š
    z = x * y;
  }
}
```
1. @titleï¼ˆæ ‡é¢˜ï¼‰ å’Œ @author ï¼ˆä½œè€…ï¼‰å¾ˆç›´æŽ¥äº†.
2. @notice ï¼ˆé¡»çŸ¥ï¼‰å‘ ç”¨æˆ· è§£é‡Šè¿™ä¸ªæ–¹æ³•æˆ–è€…åˆçº¦æ˜¯åšä»€ä¹ˆçš„ã€‚ @dev ï¼ˆå¼€å‘è€…ï¼‰ æ˜¯å‘å¼€å‘è€…è§£é‡Šæ›´å¤šçš„ç»†èŠ‚ã€‚
3. @param ï¼ˆå‚æ•°ï¼‰å’Œ @return ï¼ˆè¿”å›žï¼‰ ç”¨æ¥æè¿°è¿™ä¸ªæ–¹æ³•éœ€è¦ä¼ å…¥ä»€ä¹ˆå‚æ•°ä»¥åŠè¿”å›žä»€ä¹ˆå€¼ã€‚

æ³¨æ„ä½ å¹¶ä¸éœ€è¦æ¯æ¬¡éƒ½ç”¨ä¸Šæ‰€æœ‰çš„æ ‡ç­¾ï¼Œå®ƒä»¬éƒ½æ˜¯å¯é€‰çš„ã€‚ä¸è¿‡æœ€å°‘ï¼Œå†™ä¸‹ä¸€ä¸ª @dev æ³¨é‡Šæ¥è§£é‡Šæ¯ä¸ªæ–¹æ³•æ˜¯åšä»€ä¹ˆçš„ã€‚

å®žæˆ˜æ¼”ä¹ ï¼š
```
/// @title ä¸€ä¸ªç®¡ç†è½¬ç§»åƒµå°¸æ‰€æœ‰æƒçš„åˆçº¦
/// @author formikasaever
/// @dev ç¬¦åˆ OpenZeppelin å¯¹ ERC721 æ ‡å‡†è‰æ¡ˆçš„å®žçŽ°
contract ZombieOwnership is ZombieAttack, ERC721 {
```
#### â‘­æ”¾åœ¨ä¸€èµ·
**æ€»ç»“ä¸€ä¸‹**
è¿™èŠ‚è¯¾é‡Œé¢æˆ‘ä»¬å­¦åˆ°äº†

- ä»£å¸, ERC721 æ ‡å‡†ï¼Œä»¥åŠå¯äº¤æ˜“çš„ç‰©ä»¶/åƒµå°¸
- åº“ä»¥åŠå¦‚ä½•ä½¿ç”¨åº“
- å¦‚ä½•åˆ©ç”¨ SafeMath æ¥é˜²æ­¢æº¢å‡ºå’Œä¸‹æº¢
- ä»£ç æ³¨é‡Šå’Œ natspec æ ‡å‡†

è¿™èŠ‚æ•™ç¨‹å®Œæˆäº†æˆ‘ä»¬æ¸¸æˆçš„ Solidity ä»£ç ï¼ˆä»…é’ˆå¯¹å½“ä¸‹æ¥è¯´ï¼Œæœªæ¥çš„è¯¾ç¨‹æˆ‘ä»¬ä¹Ÿè®¸ä¼šåŠ å…¥æ›´å¤šè¿›åŽ»ï¼‰ã€‚

åœ¨æŽ¥ä¸‹æ¥çš„ä¸¤èŠ‚è¯¾ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å°†æ¸¸æˆéƒ¨ç½²åˆ°ä»¥å¤ªåŠä»¥åŠå’Œ web3.js äº¤äº’ ï¼ˆè¿™æ ·ä½ å°±èƒ½ä¸ºä½ çš„ DApp æ‰“é€ ä¸€ä¸ªç•Œé¢äº† ï¼‰ã€‚
#### â‘®ç¬¬äº”è¯¾å®Œæˆ
æˆªè‡³ç¬¬äº”è¯¾å®Œæˆï¼Œæ‰€æœ‰ä»£ç å¦‚ä¸‹ï¼š
**zombieownership.sol:**
```
pragma solidity ^0.4.19;

import "./zombieattack.sol";
import "./erc721.sol";
import "./safemath.sol";

/// @title ä¸€ä¸ªç®¡ç†è½¬ç§»åƒµå°¸æ‰€æœ‰æƒçš„åˆçº¦
/// @author formikasaever
/// @dev ç¬¦åˆ OpenZeppelin å¯¹ ERC721 æ ‡å‡†è‰æ¡ˆçš„å®žçŽ°
contract ZombieOwnership is ZombieAttack, ERC721 {

  using SafeMath for uint256;

  mapping (uint => address) zombieApprovals;

  function balanceOf(address _owner) public view returns (uint256 _balance) {
    return ownerZombieCount[_owner];
  }

  function ownerOf(uint256 _tokenId) public view returns (address _owner) {
    return zombieToOwner[_tokenId];
  }

  function _transfer(address _from, address _to, uint256 _tokenId) private {
    ownerZombieCount[_to] = ownerZombieCount[_to].add(1);
    ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);
    zombieToOwner[_tokenId] = _to;
    Transfer(_from, _to, _tokenId);
  }

  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    _transfer(msg.sender, _to, _tokenId);
  }

  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
    zombieApprovals[_tokenId] = _to;
    Approval(msg.sender, _to, _tokenId);
  }

  function takeOwnership(uint256 _tokenId) public {
    require(zombieApprovals[_tokenId] == msg.sender);
    address owner = ownerOf(_tokenId);
    _transfer(owner, msg.sender, _tokenId);
  }
}
```
**zombieattack.sol:**
```
pragma solidity ^0.4.19;

import "./zombiehelper.sol";

contract ZombieBattle is ZombieHelper {
  uint randNonce = 0;
  uint attackVictoryProbability = 70;

  function randMod(uint _modulus) internal returns(uint) {
    randNonce++;
    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
  }

  function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) {
    Zombie storage myZombie = zombies[_zombieId];
    Zombie storage enemyZombie = zombies[_targetId];
    uint rand = randMod(100);
    if (rand <= attackVictoryProbability) {
      myZombie.winCount++;
      myZombie.level++;
      enemyZombie.lossCount++;
      feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
    } else {
      myZombie.lossCount++;
      enemyZombie.winCount++;
      _triggerCooldown(myZombie);
    }
  }
}
```
**zombiehelper.sol:**
```
pragma solidity ^0.4.19;

import "./zombiefeeding.sol";

contract ZombieHelper is ZombieFeeding {

  uint levelUpFee = 0.001 ether;

  modifier aboveLevel(uint _level, uint _zombieId) {
    require(zombies[_zombieId].level >= _level);
    _;
  }

  function withdraw() external onlyOwner {
    owner.transfer(this.balance);
  }

  function setLevelUpFee(uint _fee) external onlyOwner {
    levelUpFee = _fee;
  }

  function levelUp(uint _zombieId) external payable {
    require(msg.value == levelUpFee);
    zombies[_zombieId].level++;
  }

  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) {
    zombies[_zombieId].name = _newName;
  }

  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) {
    zombies[_zombieId].dna = _newDna;
  }

  function getZombiesByOwner(address _owner) external view returns(uint[]) {
    uint[] memory result = new uint[](ownerZombieCount[_owner]);
    uint counter = 0;
    for (uint i = 0; i < zombies.length; i++) {
      if (zombieToOwner[i] == _owner) {
        result[counter] = i;
        counter++;
      }
    }
    return result;
  }

}
```
**zombiefeeding.sol:**
```
pragma solidity ^0.4.19;

import "./zombiefactory.sol";

contract KittyInterface {
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}

contract ZombieFeeding is ZombieFactory {

  KittyInterface kittyContract;

  modifier onlyOwnerOf(uint _zombieId) {
    require(msg.sender == zombieToOwner[_zombieId]);
    _;
  }

  function setKittyContractAddress(address _address) external onlyOwner {
    kittyContract = KittyInterface(_address);
  }

  function _triggerCooldown(Zombie storage _zombie) internal {
    _zombie.readyTime = uint32(now + cooldownTime);
  }

  function _isReady(Zombie storage _zombie) internal view returns (bool) {
      return (_zombie.readyTime <= now);
  }

  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal onlyOwnerOf(_zombieId) {
    Zombie storage myZombie = zombies[_zombieId];
    require(_isReady(myZombie));
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    if (keccak256(_species) == keccak256("kitty")) {
      newDna = newDna - newDna % 100 + 99;
    }
    _createZombie("NoName", newDna);
    _triggerCooldown(myZombie);
  }

  function feedOnKitty(uint _zombieId, uint _kittyId) public {
    uint kittyDna;
    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
    feedAndMultiply(_zombieId, kittyDna, "kitty");
  }
}
```
**zombiefactory.sol:**
```
pragma solidity ^0.4.19;

import "./ownable.sol";
import "./safemath.sol";

contract ZombieFactory is Ownable {

  using SafeMath for uint256;

  event NewZombie(uint zombieId, string name, uint dna);

  uint dnaDigits = 16;
  uint dnaModulus = 10 ** dnaDigits;
  uint cooldownTime = 1 days;

  struct Zombie {
    string name;
    uint dna;
    uint32 level;
    uint32 readyTime;
    uint16 winCount;
    uint16 lossCount;
  }

  Zombie[] public zombies;

  mapping (uint => address) public zombieToOwner;
  mapping (address => uint) ownerZombieCount;

  function _createZombie(string _name, uint _dna) internal {
    uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
    zombieToOwner[id] = msg.sender;
    ownerZombieCount[msg.sender]++;
    NewZombie(id, _name, _dna);
  }

  function _generateRandomDna(string _str) private view returns (uint) {
    uint rand = uint(keccak256(_str));
    return rand % dnaModulus;
  }

  function createRandomZombie(string _name) public {
    require(ownerZombieCount[msg.sender] == 0);
    uint randDna = _generateRandomDna(_name);
    randDna = randDna - randDna % 100;
    _createZombie(_name, randDna);
  }

}
```
**ownable.sol:**
```
pragma solidity ^0.4.19;
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}
```
**safemath.sol:**
```
pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```
**erc721.sol:**
```
pragma solidity ^0.4.19;
contract ERC721 {
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

  function balanceOf(address _owner) public view returns (uint256 _balance);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function transfer(address _to, uint256 _tokenId) public;
  function approve(address _to, uint256 _tokenId) public;
  function takeOwnership(uint256 _tokenId) public;
}
```
***
### å¿ƒå¾— 
#### â‘ 